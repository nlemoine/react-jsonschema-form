"use strict";(self.webpackChunk_rjsf_docs=self.webpackChunk_rjsf_docs||[]).push([[2462],{975:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"advanced-customization/typescript","title":"Typescript Support","description":"RJSF fully supports Typescript.","source":"@site/docs/advanced-customization/typescript.md","sourceDirName":"advanced-customization","slug":"/advanced-customization/typescript","permalink":"/react-jsonschema-form/docs/advanced-customization/typescript","draft":false,"unlisted":false,"editUrl":"https://github.com/rjsf-team/react-jsonschema-form/tree/main/packages/docs/docs/advanced-customization/typescript.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Internals","permalink":"/react-jsonschema-form/docs/advanced-customization/internals"},"next":{"title":"API Reference","permalink":"/react-jsonschema-form/docs/api-reference/"}}');var o=t(1085),s=t(1184);const a={},i="Typescript Support",c={},m=[{value:"Overriding generics",id:"overriding-generics",level:2},{value:"T",id:"t",level:3},{value:"S",id:"s",level:3},{value:"F",id:"f",level:3},{value:"Overriding generics in core",id:"overriding-generics-in-core",level:2},{value:"Overriding generics in other themes",id:"overriding-generics-in-other-themes",level:2},{value:"Overriding a Theme",id:"overriding-a-theme",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"typescript-support",children:"Typescript Support"})}),"\n",(0,o.jsxs)(n.p,{children:["RJSF fully supports Typescript.\nThe ",(0,o.jsx)(n.a,{href:"/react-jsonschema-form/docs/api-reference/utility-functions",children:"types and functions"})," exported by ",(0,o.jsx)(n.code,{children:"@rjsf/utils"})," are fully typed (as needed) using one or more of the following 3 optional generics:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"T = any"}),": This represents the type of the ",(0,o.jsx)(n.code,{children:"formData"})," and defaults to ",(0,o.jsx)(n.code,{children:"any"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"S extends StrictRJSFSchema = RJSFSchema"}),": This represents the type of the ",(0,o.jsx)(n.code,{children:"schema"})," and extends the ",(0,o.jsx)(n.code,{children:"StrictRJSFSchema"})," type and defaults to the ",(0,o.jsx)(n.code,{children:"RJSFSchema"})," type."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"F extends FormContextType = any"}),": This represents the type of the ",(0,o.jsx)(n.code,{children:"formContext"}),", extends the ",(0,o.jsx)(n.code,{children:"FormContextType"})," type and defaults to ",(0,o.jsx)(n.code,{children:"any"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Every other library in the ",(0,o.jsx)(n.code,{children:"@rjsf/*"})," ecosystem use these same generics in their functions and React component definitions.\nFor instance, in the ",(0,o.jsx)(n.code,{children:"@rjsf/core"})," library the definitions of the ",(0,o.jsx)(n.code,{children:"Form"})," component and the ",(0,o.jsx)(n.code,{children:"withTheme()"})," and ",(0,o.jsx)(n.code,{children:"getDefaultRegistry()"})," functions are as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export default class Form<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> extends Component<FormProps<T, S, F>, FormState<T, S, F>> {\n  // ... class implementation\n}\n\nexport default function withTheme<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  themeProps: ThemeProps<T, S, F>\n) {\n  // ... function implementation\n}\n\nexport default function getDefaultRegistry<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(): Omit<Registry<T, S, F>, 'schemaUtils'> {\n  // ... function implementation\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Out of the box, the defaults for these generics will work for all use-cases.\nProviding custom types for any of these generics may be useful for situations where the caller is working with typed ",(0,o.jsx)(n.code,{children:"formData"}),", ",(0,o.jsx)(n.code,{children:"schema"})," or ",(0,o.jsx)(n.code,{children:"formContext"})," props, Typescript is complaining and type casting isn't allowed."]}),"\n",(0,o.jsx)(n.h2,{id:"overriding-generics",children:"Overriding generics"}),"\n",(0,o.jsx)(n.h3,{id:"t",children:"T"}),"\n",(0,o.jsxs)(n.p,{children:["The generic ",(0,o.jsx)(n.code,{children:"T"})," is used to represent the type of the ",(0,o.jsx)(n.code,{children:"formData"})," property passed into ",(0,o.jsx)(n.code,{children:"Form"}),".\nIf you are working with a simple, unchanging JSON Schema and you have defined a type for the ",(0,o.jsx)(n.code,{children:"formData"})," you are working with, you can override this generic as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport { Form } from '@rjsf/core';\n\ninterface FormData {\n  foo?: string;\n  bar?: number;\n}\n\nconst schema: RJSFSchema = {\n  type: 'object',\n  properties: {\n    foo: { type: 'string' },\n    bar: { type: 'number' },\n  },\n};\n\nconst formData: FormData = {};\n\nconst validator = customizeValidator<FormData>();\n\nrender(<Form<FormData> schema={schema} validator={validator} formData={formData} />, document.getElementById('app'));\n"})}),"\n",(0,o.jsx)(n.h3,{id:"s",children:"S"}),"\n",(0,o.jsxs)(n.p,{children:["The generic ",(0,o.jsx)(n.code,{children:"S"})," is used to represent the type of the ",(0,o.jsx)(n.code,{children:"schema"})," property passed into ",(0,o.jsx)(n.code,{children:"Form"}),".\nIf you are using something like the ",(0,o.jsx)(n.a,{href:"https://ajv.js.org/guide/typescript.html#utility-types-for-schemas",children:"Ajv utility types for schemas"})," typing system, you can override this generic as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { JSONSchemaType } from 'ajv';\nimport { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport { Form } from '@rjsf/core';\n\ninterface FormData {\n  foo?: string;\n  bar?: number;\n}\n\ntype MySchema = JSONSchemaType<FormData>;\n\nconst schema: MySchema = {\n  type: 'object',\n  properties: {\n    foo: { type: 'string' },\n    bar: { type: 'number' },\n  },\n};\n\nconst validator = customizeValidator<any, MySchema>();\n\nrender(<Form<any, MySchema> schema={schema} validator={validator} />, document.getElementById('app'));\n\n// Alternatively since you have the type, you could also use this\n// const validator = customizeValidator<FormData, MySchema>();\n// render((\n//  <Form<FormData, MySchema> schema={schema} validator={validator} />\n//), document.getElementById(\"app\"));\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["NOTE: using this ",(0,o.jsx)(n.code,{children:"Ajv typing system"})," has not been tested extensively with RJSF, so use carefully"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"f",children:"F"}),"\n",(0,o.jsxs)(n.p,{children:["The generic ",(0,o.jsx)(n.code,{children:"F"})," is used to represent the type of the ",(0,o.jsx)(n.code,{children:"formContext"})," property passed into ",(0,o.jsx)(n.code,{children:"Form"}),".\nIf you have a type for this data, you can override this generic as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport { Form } from '@rjsf/core';\n\ninterface FormContext {\n  myCustomWidgetData: object;\n}\n\nconst schema: RJSFSchema = {\n  type: 'object',\n  properties: {\n    foo: { type: 'string' },\n    bar: { type: 'number' },\n  },\n};\n\nconst formContext: FormContext = {\n  myCustomWidgetData: {\n    enableCustomFeature: true,\n  },\n};\n\nconst validator = customizeValidator<any, RJSFSchema, FormContext>();\n\nrender(\n  <Form<any, RJSFSchema, FormContext> schema={schema} validator={validator} formContext={formContext} />,\n  document.getElementById('app')\n);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"overriding-generics-in-core",children:"Overriding generics in core"}),"\n",(0,o.jsxs)(n.p,{children:["As shown in previous examples, overriding the default ",(0,o.jsx)(n.code,{children:"Form"})," from ",(0,o.jsx)(n.code,{children:"@rjsf/core"})," is pretty straight forward.\nUsing the ",(0,o.jsx)(n.code,{children:"withTheme()"})," function is just as easy:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport { withTheme, ThemeProps } from '@rjsf/core';\n\ninterface FormData {\n  foo?: string;\n  bar?: number;\n}\n\ntype MySchema = JSONSchemaType<FormData>;\n\nconst schema: MySchema = {\n  type: 'object',\n  properties: {\n    foo: { type: 'string' },\n    bar: { type: 'number' },\n  },\n};\n\ninterface FormContext {\n  myCustomWidgetData: object;\n}\n\nconst theme: ThemeProps<FormData, MySchema, FormContext> = {\n  widgets: { test: () => <div>test</div> },\n};\n\nconst ThemedForm = withTheme<FormData, MySchema, FormContext>(theme);\n\nconst validator = customizeValidator<FormData, MySchema, FormContext>();\n\nconst Demo = () => <ThemedForm schema={schema} uiSchema={uiSchema} validator={validator} />;\n"})}),"\n",(0,o.jsx)(n.h2,{id:"overriding-generics-in-other-themes",children:"Overriding generics in other themes"}),"\n",(0,o.jsxs)(n.p,{children:["Since all the other themes in RJSF are extensions of ",(0,o.jsx)(n.code,{children:"@rjsf/core"}),", overriding parts of these themes with custom generics is a little different.\nThe exported ",(0,o.jsx)(n.code,{children:"Theme"})," and ",(0,o.jsx)(n.code,{children:"Form"})," from any of the themes have been created using the generic defaults, and as a result, do not take generics themselves.\nIn order to override generics, special ",(0,o.jsx)(n.code,{children:"generateForm()"})," and ",(0,o.jsx)(n.code,{children:"generateTheme()"})," functions are exported for your use."]}),"\n",(0,o.jsx)(n.h3,{id:"overriding-a-theme",children:"Overriding a Theme"}),"\n",(0,o.jsxs)(n.p,{children:["If you are doing something like the following to create a new theme based on ",(0,o.jsx)(n.code,{children:"@rjsf/mui"})," to extend one or more ",(0,o.jsx)(n.code,{children:"templates"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import React from 'react';\nimport { WidgetProps } from '@rjsf/utils';\nimport { ThemeProps, withTheme } from '@rjsf/core';\nimport validator from '@rjsf/validator-ajv8';\nimport { Theme } from '@rjsf/mui';\n\nconst OldBaseInputTemplate = Theme.templates.BaseInputTemplate;\n\n// Force the underlying `TextField` component to always use size=\"small\"\nfunction MyBaseInputTemplate(props: WidgetProps) {\n  return <OldBaseInputTemplate {...props} size='small' />;\n}\n\nconst myTheme: ThemeProps = {\n  ...Theme,\n  templates: {\n    ...Theme.templates,\n    BaseInputTemplate: MyBaseInputTemplate,\n  },\n};\n\nconst ThemedForm = withTheme(myTheme);\n\nconst Demo = () => <ThemedForm schema={schema} uiSchema={uiSchema} validator={validator} />;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Then you would use the new ",(0,o.jsx)(n.code,{children:"generateTheme()"})," and ",(0,o.jsx)(n.code,{children:"generateForm()"})," functions as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import React from 'react';\nimport { WidgetProps } from '@rjsf/utils';\nimport { ThemeProps, withTheme } from '@rjsf/core';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport { generateTheme } from '@rjsf/mui';\n\ninterface FormData {\n  foo?: string;\n  bar?: number;\n}\n\ntype MySchema = JSONSchemaType<FormData>;\n\nconst schema: MySchema = {\n  type: 'object',\n  properties: {\n    foo: { type: 'string' },\n    bar: { type: 'number' },\n  },\n};\n\ninterface FormContext {\n  myCustomWidgetData: object;\n}\n\nconst Theme: ThemeProps<FormData, MySchema, FormContext> = generateTheme<FormData, MySchema, FormContext>();\n\nconst OldBaseInputTemplate = Theme.templates.BaseInputTemplate;\n\n// Force the underlying `TextField` component to always use size=\"small\"\nfunction MyBaseInputTemplate(props: WidgetProps<FormData, MySchema, FormContext>) {\n  return <OldBaseInputTemplate {...props} size='small' />;\n}\n\nconst myTheme: ThemeProps<FormData, MySchema, FormContext> = {\n  ...Theme,\n  templates: {\n    ...Theme.templates,\n    BaseInputTemplate: MyBaseInputTemplate,\n  },\n};\n\nconst ThemedForm = withTheme<FormData, MySchema, FormContext>(myTheme);\n\nconst validator = customizeValidator<FormData, MySchema, FormContext>();\n\n// You could also do since they are effectively the same:\n// const ThemedForm = generateForm<FormData, MySchema, FormContext>(myTheme);\n\nconst Demo = () => <ThemedForm schema={schema} uiSchema={uiSchema} validator={validator} />;\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["NOTE: The same approach works for extending ",(0,o.jsx)(n.code,{children:"widgets"})," and ",(0,o.jsx)(n.code,{children:"fields"})," as well."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(4041);const o={},s=r.createContext(o);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);